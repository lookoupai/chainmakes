# API 请求频率优化说明

## 优化目标

降低 OKX API 请求频率，避免：
- 触发 API 频率限制
- 网络连接不稳定导致的错误
- 服务器负载过高
- 提高系统整体稳定性

## 优化前的状态

### 请求频率分析

**单个机器人每5秒循环一次：**
- `get_ticker()` × 2次（market1 和 market2）
- `get_position()` × N次（每个持仓一次）
- 每小时 API 请求：**约 1,440+ 次**

**多个机器人场景：**
- 3个机器人：**4,320+ 次/小时**
- 5个机器人：**7,200+ 次/小时**

### 潜在问题

1. **API 限流风险**：OKX 有请求频率限制
2. **网络稳定性**：频繁请求容易遇到连接问题
3. **资源浪费**：实时价格变化不需要5秒更新一次
4. **服务器压力**：数据库写入频繁

## 优化方案

### 1. 增加主循环间隔 ⏱️

**修改前：**
```python
await asyncio.sleep(5)  # 每5秒检查一次
```

**修改后：**
```python
await asyncio.sleep(10)  # 每10秒检查一次，降低API请求频率
```

**效果：**
- API 请求频率降低 **50%**
- 单机器人：**~720 次/小时**
- 对套利策略影响极小（价差变化不会太快）

---

### 2. 添加价格缓存机制 💾

**实现方式：**
```python
# 价格缓存机制
self._price_cache = {}
self._price_cache_time = {}
self._price_cache_ttl = 5  # 缓存5秒

async def _get_market_price(self, symbol: str) -> Decimal:
    """获取市场价格（带缓存）"""
    current_time = time.time()

    # 检查缓存
    if symbol in self._price_cache:
        cache_time = self._price_cache_time.get(symbol, 0)
        if current_time - cache_time < self._price_cache_ttl:
            # 缓存有效，直接返回
            return self._price_cache[symbol]

    # 缓存失效，从交易所获取
    ticker = await self.exchange.get_ticker(symbol)
    price = ticker['last_price']

    # 更新缓存
    self._price_cache[symbol] = price
    self._price_cache_time[symbol] = current_time

    return price
```

**效果：**
- 在一个循环周期内，同一交易对只请求一次
- 进一步降低 **30-40%** 的请求量
- 价格数据延迟 < 5秒（完全可接受）

---

### 3. 优化持仓更新频率 📊

**修改前：**
```python
# 每个循环都更新持仓（5秒一次）
await self.update_position_prices()
```

**修改后：**
```python
# 持仓更新频率控制
self._position_update_counter = 0
self._position_update_interval = 3  # 每3个循环更新一次

# 每3个循环才更新一次持仓（30秒一次）
self._position_update_counter += 1
if self._position_update_counter >= self._position_update_interval:
    self._position_update_counter = 0
    await self.update_position_prices()
else:
    logger.debug(f"跳过持仓更新（{self._position_update_counter}/{self._position_update_interval}）")
```

**效果：**
- 持仓更新从 5秒一次 → 30秒一次
- 降低 **83%** 的持仓查询请求
- 盈亏显示延迟 < 30秒（可接受）

---

## 优化效果对比

### API 请求频率对比表

| 场景 | 优化前（5秒循环） | 优化后（10秒循环 + 缓存） | 减少比例 |
|------|------------------|------------------------|----------|
| **单机器人/小时** | ~1,440 次 | ~360 次 | **↓ 75%** |
| **单机器人/天** | ~34,560 次 | ~8,640 次 | **↓ 75%** |
| **3个机器人/小时** | ~4,320 次 | ~1,080 次 | **↓ 75%** |
| **5个机器人/小时** | ~7,200 次 | ~1,800 次 | **↓ 75%** |

### 具体改进

| 优化项 | 改进效果 | 对策略影响 |
|--------|---------|----------|
| 主循环间隔 10秒 | ↓ 50% 请求 | ✅ 无影响 |
| 价格缓存 5秒 | ↓ 30-40% 请求 | ✅ 无影响（延迟<5s） |
| 持仓更新 30秒 | ↓ 83% 持仓查询 | ✅ 可接受（延迟<30s） |
| **总体效果** | **↓ 75% 总请求** | ✅ 对交易策略几乎无影响 |

---

## 配置参数说明

### 可调整的参数

在 `bot_engine.py` 中可以根据需要调整以下参数：

```python
# 主循环间隔（秒）
await asyncio.sleep(10)  # 建议范围：10-30秒

# 价格缓存时间（秒）
self._price_cache_ttl = 5  # 建议范围：3-10秒

# 持仓更新间隔（循环次数）
self._position_update_interval = 3  # 建议范围：2-6次（即20-60秒）
```

### 参数选择建议

| 交易风格 | 主循环间隔 | 价格缓存TTL | 持仓更新间隔 |
|---------|-----------|------------|------------|
| **激进型** | 10秒 | 3秒 | 2次循环 |
| **平衡型** | 10秒 | 5秒 | 3次循环 | ✅ 当前配置
| **保守型** | 15-20秒 | 8-10秒 | 4-6次循环 |

---

## 风险评估

### ✅ 低风险

1. **价差监控延迟**
   - 延迟：5-10秒
   - 影响：极小（套利价差不会瞬间消失）

2. **持仓盈亏显示延迟**
   - 延迟：<30秒
   - 影响：仅影响显示，不影响交易决策

### ⚠️ 需要注意

1. **快速波动市场**
   - 在极端行情下，可能错过快速价差机会
   - 建议：监控市场波动性，必要时调整参数

2. **多机器人并发**
   - 虽然降低了75%请求，但多机器人仍需注意总量
   - 建议：5个以内机器人同时运行

---

## 监控建议

### 日志监控

观察以下日志判断优化效果：

```bash
# 1. 缓存命中日志
使用缓存价格: BTC/USDT:USDT = 65432.5

# 2. 持仓更新跳过日志
跳过持仓更新（1/3）
跳过持仓更新（2/3）

# 3. 循环执行时间
[BotEngine] Bot 11 第 100 次循环完成，等待10秒
```

### 性能指标

```python
# 每100次循环会输出性能统计
[BotEngine] Bot 11 性能统计 -
  总循环: 100,
  平均耗时: 0.856s,  # 应该 < 2秒
  最近100次平均: 0.823s,
  本次耗时: 0.905s
```

**性能标准：**
- 单次循环耗时：**< 2秒**为优秀
- 平均耗时：**< 1秒**为理想

---

## 回滚方案

如果发现优化后策略表现不佳，可以快速回滚：

### 方案 1：恢复5秒循环

```python
# bot_engine.py 第110行
await asyncio.sleep(5)  # 改回5秒
```

### 方案 2：禁用价格缓存

```python
# bot_engine.py 第66行
self._price_cache_ttl = 0  # 设为0禁用缓存
```

### 方案 3：增加持仓更新频率

```python
# bot_engine.py 第70行
self._position_update_interval = 1  # 每个循环都更新
```

---

## 后续优化建议

### 1. WebSocket 实时价格推送
- 替代 REST API 轮询
- 真正的实时价格（延迟 < 100ms）
- 大幅降低 API 请求量

### 2. 批量 API 请求
- 使用 OKX 的批量查询接口
- 一次请求获取多个交易对价格

### 3. 智能间隔调整
- 根据价差变化动态调整循环间隔
- 价差接近阈值时加快检查频率

### 4. 请求队列管理
- 全局请求队列控制
- 避免多机器人同时请求

---

## 测试建议

### 1. 功能测试

- [ ] 价格获取正常
- [ ] 缓存机制生效
- [ ] 持仓更新正常
- [ ] 开仓/平仓功能正常

### 2. 性能测试

- [ ] 单机器人运行稳定
- [ ] 多机器人并发稳定
- [ ] API 请求频率符合预期
- [ ] 无网络错误增加

### 3. 策略测试

- [ ] 价差监控准确
- [ ] 开仓信号不遗漏
- [ ] 止盈止损正常触发
- [ ] 整体收益未受影响

---

## 更新日志

- **2025-10-11**
  - 主循环间隔从5秒增加到10秒
  - 添加价格缓存机制（5秒TTL）
  - 持仓更新频率从5秒降低到30秒
  - 预计降低75% API请求量

---

## 相关文件

- `backend/app/core/bot_engine.py` - 机器人核心引擎
- `backend/app/exchanges/okx_exchange.py` - OKX 交易所适配器
- `docs/NETWORK_RETRY_FIX.md` - 网络重试机制文档
